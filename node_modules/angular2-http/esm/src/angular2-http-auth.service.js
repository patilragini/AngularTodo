import { Injectable } from '@angular/core';
import { StorageService } from './angular2-http-storage.service';
var JwtHelper = (function () {
    function JwtHelper() {
    }
    JwtHelper.urlBase64Decode = function (str) {
        var output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw 'Illegal base64url string!';
            }
        }
        return this.b64DecodeUnicode(output);
    };
    JwtHelper.b64DecodeUnicode = function (str) {
        return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), function (c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    };
    JwtHelper.b64decode = function (str) {
        var output = '';
        str = String(str).replace(/=+$/, '');
        if (str.length % 4 == 1) {
            throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
        }
        for (
        // initialize result and counters
        var bc = 0, bs = void 0, buffer = void 0, idx = 0; 
        // get next character
        buffer = str.charAt(idx++); 
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
            // and if not first of each 4 characters,
            // convert the first 8 bits to one ascii character
            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
            // try to find character in table (0-63, not found => -1)
            buffer = this.CHARS.indexOf(buffer);
        }
        return output;
    };
    JwtHelper.decodeToken = function (token) {
        var parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('JWT must have 3 parts');
        }
        var decoded = this.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token');
        }
        return JSON.parse(decoded);
    };
    return JwtHelper;
}());
JwtHelper.CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var AuthService = (function () {
    function AuthService(storage) {
        this.storage = storage;
    }
    AuthService.prototype.setToken = function (token) {
        if (!this.isTokenExpired(token)) {
            this.storage.setToken(token);
        }
    };
    AuthService.prototype.removeToken = function () {
        this.storage.removeToken();
    };
    AuthService.prototype.isLoggedIn = function () {
        return this.storage.getToken() && !this.isTokenExpired();
    };
    AuthService.prototype.getUsername = function () {
        return this.getTokenProperty('unique_name');
    };
    AuthService.prototype.getTokenProperty = function (property) {
        if (!this.isLoggedIn()) {
            return undefined;
        }
        return this.decodeToken()[property];
    };
    AuthService.prototype.hasClaim = function (claimType, claimValue) {
        var value = this.getTokenProperty(claimType);
        if (Array.isArray(value)) {
            return value.indexOf(claimValue) >= 0;
        }
        else {
            return value === claimValue;
        }
    };
    AuthService.prototype.decodeToken = function (token) {
        return JwtHelper.decodeToken(token || this.storage.getToken());
    };
    AuthService.prototype.isTokenExpired = function (token) {
        var date = this.getTokenExpirationDate(token);
        if (!date) {
            return false;
        }
        // Token expired?
        return date.valueOf() <= new Date().valueOf();
    };
    AuthService.prototype.getTokenExpirationDate = function (token) {
        var decoded = this.decodeToken(token);
        if (!decoded.exp) {
            return null;
        }
        var date = new Date(0);
        date.setUTCDate(decoded.exp);
        return date;
    };
    return AuthService;
}());
export { AuthService };
AuthService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AuthService.ctorParameters = function () { return [
    { type: StorageService, },
]; };
//# sourceMappingURL=angular2-http-auth.service.js.map